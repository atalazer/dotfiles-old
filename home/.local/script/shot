#!/usr/bin/env bash

#vim: ft=sh: sw=2: ts=2:

CONF=~/.config/script/shot.conf

default_config(){
    _XDG_="$(xdg-user-dir PICTURES)/Screenshots"
    ASSET_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/script/shot"
    SCREENSHOT_DIR="${_XDG_:-$HOME/Pictures/Screenshots}"
    SAVED_NAME="$SCREENSHOT_DIR/$(date +%Y%m%d-%H%M%S)-shot.png"
    TMP_DIR="/tmp"
    TMP_FILE="$TMP_DIR/image"
    IMG_EXT="png"
    TMP_IMG="$TMP_FILE.$IMG_EXT"

    DMENU="rofi -dmenu -i -p Screenshot -lines 6 -width 20"
    
    sleep=3
    max_history=5

    border_size=0
    rounded_corner=0
    shadow_size="80x5+0+0"

    background_size=3
    background_color="#ffffff"
    color_fg="#ffffff"
    color_bg="#1F2233"
    color_profile="/usr/share/color/icc/colord/sRGB.icc"

    font_size=12
    font='Fura-Code-Regular-Nerd-Font-Complete'

    add_author=false
    author_position=("SouthEast" "+10+10")
    author="@${USER}"

    add_text=false
    long_text="$(date '+%A, %d/%m/%Y')"
    short_text="$(date '+%d/%m/%Y')"

    add_titlebar=false
    use_custom_titlebar=false
    titlebar_only_active=true

    close_icon="$ASSET_DIR/close.png"
    min_icon="$ASSET_DIR/minimize.png"
    max_icon="$ASSET_DIR/maximize.png"
}

[[ -f $CONF ]] && source $CONF || default_config

if [ ! -d "$SCREENSHOT_DIR" ]; then
    /bin/mkdir -p "$SCREENSHOT_DIR"
fi

clean() {
    if [[ -f $TMP_IMG ]]; then
        # /usr/bin/rm "$TMP_IMG"
        /usr/bin/mv $TMP_IMG "${TMP_FILE}-$(date '+%H%M%S').${IMG_EXT}"

        if [[ $(ls $TMP_DIR | grep ".${IMG_EXT}" > $TMP_DIR/total-image && \
            wc -l < $TMP_DIR/total-image) == $max_history ]]; then
            /usr/bin/rm "${TMP_DIR}/*.${IMG_EXT}"
            /usr/bin/rm $TMP_DIR/total-image
        fi
    fi
}

# Check DE/WM
check_wm() {
    # Identify environment
    DE="${DESKTOP_STARTUP_ID}"
    if [[ ! -z $DE && $DE == *"awesome"* ]] || [[ -n $CHECK_AWESOME_CLIENT ]]; then
        echo "AWESOME"
        return
    fi
    echo "NOT_AWESOME"
}

parse() {
    notify-send -t $((1000 * 3)) --app-name=screenshot "Shot" "Parsing Image"

    IMG=$TMP_IMG
    DIR=/tmp

    width=$(identify -format "%w" $IMG)
    height=$(identify -format "%h" $IMG)
    if [[ $add_text == true ]]; then
        if [[ -n $text ]]; then
            text=$text
        else
            text="$long_text"
            if ((width <= 200)); then
                text="$shor_text"
            fi
        fi
    else
        text=""
    fi

    if [[ $use_custom_titlebar == true ]]; then
        convert $IMG \
            -font $font -gravity north \
            -background ${color_bg} -fill ${color_fg} \
            -splice 0x28 -annotate +0+7 "${text}" \
            $IMG

        convert $IMG \
            -gravity NorthWest -draw "image Over 13,7 0,0 '${close_icon}'" \
            -gravity NorthWest -draw "image Over 33,7 0,0 '${min_icon}'" \
            -gravity NorthWest -draw "image Over 53,7 0,0 '${max_icon}'" \
            $IMG

        # Set rounded corner
        convert "$IMG" \( +clone -alpha extract -draw 'fill black polygon 0,0 0,'"${rounded_corner}"' '"${rounded_corner}"',0 fill white circle '"${rounded_corner}"','"${rounded_corner}"' '"${rounded_corner}"',0' \
            \( +clone -flip \) -compose Multiply -composite \
            \( +clone -flop \) -compose Multiply -composite \
            \) -alpha off -compose CopyOpacity -composite -compose over "$IMG"
    fi

    if [[ $border_size -ge 3 ]]; then
        # Generate image info
        convert "$IMG" \
            -format 'roundrectangle 1,1 %[fx:w+4],%[fx:h+4] '"${rounded_corner}"','"${rounded_corner}"'' \
            info: >$DIR/_rounded_.mvg

        # Generate rounding masked
        convert "$IMG" -border ${border_size} -alpha transparent \
            -background none -fill white -stroke none -strokewidth 0 \
            -draw "@"$DIR"/_rounded_.mvg" $DIR/_rounded_mask_.png

        # Generate rounding overlay
        convert "$IMG" -border ${border_size} -alpha transparent \
            -background none -fill none -stroke ${color_fg} -strokewidth ${border_size} \
            -draw "@"$DIR"/_rounded_.mvg" $DIR/_rounded_overlay_.png

        # Set rounded corner & border
        convert "$IMG" -alpha set -bordercolor none -border ${border_size} \
            $DIR/_rounded_mask_.png -compose DstIn -composite \
            $DIR/_rounded_overlay_.png -compose Over -composite \
            "$IMG"
    else
        # Set rounded corner
        convert "$IMG" \( +clone -alpha extract -draw 'fill black polygon 0,0 0,'"${rounded_corner}"' '"${rounded_corner}"',0 fill white circle '"${rounded_corner}"','"${rounded_corner}"' '"${rounded_corner}"',0' \
            \( +clone -flip \) -compose Multiply -composite \
            \( +clone -flop \) -compose Multiply -composite \
            \) -alpha off -compose CopyOpacity -composite -compose over "$IMG"
    fi


    # Set image shadow
    convert $IMG \
        \( +clone -background black \
        -shadow ${shadow_size} \) +swap -background none \
        -layers merge +repage $IMG

    # Set image border
    convert "$IMG" \
        -bordercolor ${background_color} \
        -border ${background_size} \
        "$IMG"

    # Set image author if enabled
    if [[ $add_author == true ]]; then
        echo -n " ${author} " | convert $IMG \
            -gravity ${author_position[0]} -pointsize ${font_size} -fill ${color_fg} \
            -undercolor ${color_bg} -font ${font} \
            -annotate ${author_position[1]} @- $IMG &&
            convert $IMG -gravity South -chop 0x$((background_size / 2)) $IMG

        # Add top bg
        convert $IMG -gravity North -background ${background_color} \
            -splice 0x$((background_size / 2)) $IMG

    fi

    # Set image profile
    convert $IMG -profile ${color_profile} $IMG

}

notify() {
    MSG=$1
    FILE=$TMP_IMG

    if [[ "$(check_wm)" == "AWESOME" ]]; then
        awesome-client "
        -- IMPORTANT NOTE: THIS PART OF THE SCRIPT IS LUA!
        local naughty = require('naughty')
        local awful = require('awful')
        local beautiful = require('beautiful')
        local dpi = beautiful.xresources.apply_dpi

        local file = '${FILE}'
        local message = '${MSG}'

        local notify_send = function(msg, action)
            if type(action) ~= 'table' then
                action = {}
            end
            naughty.notification ({
                app_name = 'screenshot',
                icon = file,
                timeout = 5,
                title = '<b>Shot</b>',
                message = msg,
                actions = action or nil,
            })
        end

        local save_image = naughty.action {
            name = 'Save',
            icon_only = false,
        }

        local rename_image = naughty.action {
            name = 'Rename',
            icon_only = false,
        }
        
        local open_image = naughty.action {
            name = 'Open',
            icon_only = false,
        }

        local open_folder = naughty.action {
            name = 'Folder',
            icon_only = false,
        }

        local delete_image = naughty.action {
            name = 'Delete',
            icon_only = false,
        }

        local to_clipboard = naughty.action {
            name = 'Clip',
            icon_only = false,
        }

        local prompt_rename_image = function()
            awful.prompt.run {
                prompt       = 'New File Name: ',
                textbox      = awful.screen.focused().mypromptbox.widget,
                history_path = awful.util.get_cache_dir() .. '/history',
                exe_callback = function(new_name)
                    if not new_name or #new_name == 0 then return end
                    local old_file_name = file
                    local new_file_name = '${SCREENSHOT_DIR}/'..new_name..'.png'
                    awful.spawn('mv '..file..' '..new_file_name, false)
                    file = new_file_name

                    awesome.emit_signal('notifbox::deleted')

                    -- notify_send('Image Renamed From <b>'..old_file_name..'</b> To <b>'..file..'</b>', {})
                    notify_send('Image Renamed To <b>'..file..'</b>',{ open_image, open_folder, to_clipboard, rename_image, delete_image })
                end
            }
        end

        delete_image:connect_signal('invoked', function()
            awesome.emit_signal('notifbox::deleted')
            awful.spawn('rm '..file, false)
            notify_send(file..' Deleted', {})
        end)

        save_image:connect_signal('invoked', function()
            awesome.emit_signal('notifbox::deleted')
            oldfile = file
            file = '${SAVED_NAME}'
            awful.spawn('cp '..oldfile..' '..file, false)
            notify_send(message, { open_image, open_folder, to_clipboard, rename_image, delete_image })
        end)

        open_image:connect_signal('invoked', function()
            awful.spawn('feh ' .. file, false)
        end)

        open_folder:connect_signal('invoked', function()
            awful.spawn('xdg-open ' .. '${SCREENSHOT_DIR}', false)
        end)

        to_clipboard:connect_signal('invoked', function()
            awful.spawn('xclip -selection clipboard -i '..file..' -t image/png', false)
        end)

        rename_image:connect_signal('invoked', function()
            prompt_rename_image()
        end)

        notify_send(message, { open_image, to_clipboard, save_image, delete_image })
        "
    elif [[ "$(check_wm)" == "NOT_AWESOME" ]]; then
        notify-send --app-name=screenshot "Shot" "${MSG}"
    fi
}

to_clip() {
    notify-send --app-name=screenshot "Shot" "Screenshot Saved to Clipboard"
    if [ $XDG_SESSION_TYPE == "wayland" ]; then
        wl-copy <$TMP_IMG
    else
        xclip -selection clipboard -i $TMP_IMG -t image/png
    fi

}

_shot() {
    clean
    if [ $XDG_SESSION_TYPE == "wayland" ]; then
        case $1 in
        normal)
            grimshot output $TMP_IMG
            ;;
        select)
            grimshot area $TMP_IMG
            ;;
        active)
            grimshot active $TMP_IMG
            ;;
        delay)
            notify-send -t $((1000 * 1)) --app-name=screenshot "Shot" "Shot After ${sleep} Sec"
            sleep $sleep &&
                grimshot output $TMP_IMG
            ;;
        esac
    else
        case $1 in
        normal)
            maim -m 10 $TMP_IMG
            ;;
        select)
            if [[ $use_custom_titlebar == true ]]; then
                maim -u -m 10 -s $TMP_IMG
            else
                maim -u -m 10 -n 0 -s $TMP_IMG
            fi
            ;;
        active)
            if [[ $use_custom_titlebar == true ]]; then
                maim -u -m 10 -i $(xdotool getactivewindow) $TMP_IMG
            else
                maim -u -m 10 -n 0 -i $(xdotool getactivewindow) $TMP_IMG
            fi
            ;;
        delay)
            notify-send -t $((1000 * 1)) --app-name=screenshot "Shot" "Shot After ${sleep} Sec"
            maim -m 10 -d $sleep $TMP_IMG
            ;;
        esac
    fi

    if [[ $titlebar_only_active == true ]]; then
        if [[ $1 == "active" ]]; then
            # add_titlebar=true
            text="$(xdotool getwindowname $(xdotool getactivewindow))"
        else
            add_titlebar=false
        fi
    fi
}

_noparse() {
    case $1 in
    full)
        _shot normal &&
            notify "Screenshot Saved"
        ;;
    active)
        _shot active &&
            notify "Screenshot from Active Windows Saved"
        ;;
    select)
        _shot select &&
            notify "Screenshot Selected Has been Saved"
        ;;
    delay)
        _shot delay &&
            notify "Screenshot Saved"
        ;;
    esac
}

_parse() {
    case $1 in
    full)
        _shot normal &&
            parse &&
            notify "Screenshot Saved"
        ;;
    active)
        _shot active &&
            parse &&
            notify "Screenshot from Active Windows Saved"
        ;;
    select)
        _shot select &&
            parse &&
            notify "Screenshot Selected Has been Saved"
        ;;
    delay)
        _shot delay &&
            parse &&
            notify "Screenshot Saved"
        ;;
    esac
}

image-to-text() {
    IMG=/tmp/image-ocr.png
    TXT=/tmp/shot-ocr

    # Get with `tesseract --list-langs`
    LANG=$(echo -e "ind\neng" | rofi -dmenu -i -l 5 -p "Target Language") &&
        notify-send -t $((1000 * 3)) --app-name=screenshot "Shot" "Select Region To Scan" &&
        _shot select

    if [[ -n $LANG ]]; then

        notify-send -t $((1000 * 3)) --app-name=screenshot "Shot" "Parse Image to Text"

        # https://tesseract-ocr.github.io/tessdoc/ImproveQuality
        # https://stackoverflow.com/questions/9480013/image-processing-to-improve-tesseract-ocr-accuracy/10034214#10034214
        # https://legacy.imagemagick.org/Usage/transform/#vision
        #
        # --- Improve Quality
        # - Add white border
        # - Remove Transparancy
        # -
        # - Monochrome
        convert $TMP_IMG \
            -bordercolor White -border 10x10 \
            -alpha off \
            -units pixelsperinch -density 300x300 -colorspace Gray -depth 8 \
            +dither -monochrome -normalize \
            $IMG

        # Textcleaner: http://www.fmwconcepts.com/imagemagick/textcleaner/index.php
        # if command -v "textcleaner" > /dev/null 2>&1; then
        #    textcleaner \
        #       -g -e none \
        #       -s 1 \
        #       $IMG $IMG
        # fi

        # Compressing
        # https://stackoverflow.com/questions/7261855/recommendation-for-compressing-jpg-files-with-imagemagick
        # convert $IMG \
        #    -strip \
        #    -interlace Plane \
        #    -gaussian-blur 0.05 \
        #    -quality 85% \
        #    $IMG

        tesseract \
            -l $LANG \
            --dpi 300 \
            $IMG \
            $TXT

        result=$(cat $TXT.txt)
        countword=$(wc -w <$TXT.txt)

        echo -n "$result" | xclip -selection clipboard
        if [[ $countword -le 30 ]]; then
            notify-send -t $((1000 * 5)) --app-name=screenshot \
                "Shot" "<b>Text Copied to Clipboard</b>:\n$result"
        else
            notify-send -t $((1000 * 3)) --app-name=screenshot \
                "Shot" "<b>Text Copied to Clipboard</b>"
        fi
    fi
}

interactive() {
    OPTIONS='''
    [
        ["Active",                  "_parse active"],
        ["Delay",                   "_parse delay"],
        ["Fullscreen",              "_parse full"],
        ["Select",                  "_parse select"],
        ["Active (Noparse)",        "_noparse active"],
        ["Fullscreen (Noparse)",    "_noparse full"],
        ["Delay (Noparse)",         "_noparse delay"],
        ["Select (Noparse)",        "_noparse select"],
        ["Image to Text",           "image-to-text"]
    ]
    '''
    menu=$(echo $OPTIONS | jq -r ".[][0]" | $DMENU)
    $(echo $OPTIONS | jq -r ".[] | select(.[0] == \"$menu\") | .[1]")
}

OPT=${1:-interactive}
case $OPT in
-a | active) _parse active ;;
-d | delay) _parse delay ;;
-f | full) _parse full ;;
-s | select) _parse select ;;
-A | active_noparse) _noparse active ;;
-D | delay_noparse) _noparse delay ;;
-F | full_noparse) _noparse full ;;
-S | select_noparse) _noparse select ;;
-i | interactive) interactive ;;
-o | ocr | image-to-text) image-to-text ;;
dump)
    echo "$_XDG_"
    echo "$ASSET_DIR"
    echo "$SCREENSHOT_DIR"
    echo "$SAVED_NAME"
    echo "$TMP_DIR"
    echo "$TMP_FILE"
    echo "$IMG_EXT"
    echo "$TMP_IMG"
    echo "$DMENU"
    echo "$sleep"
    echo "$max_history"
    echo "$border_size"
    echo "$rounded_corner"
    echo "$shadow_size"
    echo "$background_size"
    echo "$background_color"
    echo "$color_fg"
    echo "$color_bg"
    echo "$color_profile"
    echo "$font_size"
    echo "$font"
    echo "$add_author"
    echo "$author_position"
    echo "$author"
    echo "$add_text"
    echo "$long_text"
    echo "$short_text"
    echo "$add_titlebar"
    echo "$use_custom_titlebar"
    echo "$titlebar_only_active"
    echo "$close_icon"
    echo "$min_icon"
    echo "$max_icon"
;;
esac
